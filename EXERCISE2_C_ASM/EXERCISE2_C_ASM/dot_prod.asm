; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

;Comment on ASM code extracted from the C code with the Microsoft (MS) C compiler

;The translation of C code by the MS compiler to a source code file with the command line 
;ML /c /Zi /coff ..\source_code_c_to_asm.asm
;creates a source code file with x86/x64 ASM code according to the compiler's settings.

;In the ASM code generated in this way, we recognize three code groups:

;1. The interface between the ASM code generated in this way and the function and data 
;structures of the executable *.exe file created by the C compiler. Here the values of the 
;function parameters of the original C function are passed to the ASM data structure.
;This code group extends to the beginning of the data processing, in the examples given here 
;to the C "for loop", which is recognizable as a comment in the generated ASM code.

;2.  The data processing  in the examples below starts with the  C "for-loop", which 
;is recognizable as a comment in the generated ASM code. The ASM code in this group attracts 
;our attention because it is where the resources intensive data processing takes place and we 
;want to learn techniques for minimizing the number of commands and further learn how to convert 
;the minimized code to the Execution Units architecture of superscalar CPUs. This allows the 
;minimized ASM code to be executed in parallel, which reduces execution time and thus reduces 
;energy consumption.The second phase ends with the end of the C "for loop".

;3. In the  third group Code  the  pointers are put back to the C code and data structure. 
;It starts with the end of the C-for loop.

	TITLE	C:\USER\\dot_prod.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_vdp_sequential
EXTRN	__RTC_Shutdown:PROC
EXTRN	__RTC_InitBase:PROC
;	COMDAT rtc$TMZ
; File c:\user\ca2_lab\2_pentium_aufgaben\a3\dot_prod.c
rtc$TMZ	SEGMENT
;__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
;__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
; Function compile flags: /Odtp /RTCsu
rtc$IMZ	ENDS
_TEXT	SEGMENT
_i$ = -4						; size = 4
_vector$ = 8						; size = 4
_dot_prod$ = 12						; size = 8
_vdp_sequential PROC

; 19   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR [ebp-4], -858993460		; ccccccccH

; 20   : 	int i;
; 21   : 
; 22   :     for (i=0; i<dim; i++){
;******************************************
;for-Schleifenkopf in x86 Assembler
	mov	DWORD PTR _i$[ebp], 0	;i=0
	jmp	SHORT $LN3@vdp_sequen
$LN2@vdp_sequen:
	mov	eax, DWORD PTR _i$[ebp]	;i++
	add	eax, 1					;i++
	mov	DWORD PTR _i$[ebp], eax	;i++
$LN3@vdp_sequen:
	cmp	DWORD PTR _i$[ebp], 1024		; 00000400H
	jge	SHORT $LN1@vdp_sequen			; i<dim
;******************************************************

;VSP-Schleifenkoerper
; 23   : 		dot_prod.sum1 += vector[i].array1 * vector[i].array2;

	mov	ecx, DWORD PTR _i$[ebp]			;Loading the loop variable i
										;Addressing mode "Indirect" [ebp]
										;PLUS Address constant DWORD PTR _i$
	mov	edx, DWORD PTR _vector$[ebp]	;Loading the initial address of the v_a
	mov	eax, DWORD PTR _i$[ebp]			;Loading the loop variable i
	mov	esi, DWORD PTR _vector$[ebp]	;Loading the initial address of the v_b
	mov	ecx, DWORD PTR [edx+ecx*8]		;Loading v_a[0] element into register ecx
	imul	ecx, DWORD PTR [esi+eax*8+4];integer MUL v_a[0], 
										;Loading v_b[0] element indirect
										;[esi+eax*8+4]:=Addrss v_b[0]: 
	add	ecx, DWORD PTR _dot_prod$[ebp]	;ADD v_a[0]*v_b[0] with dot_prod
	mov	DWORD PTR _dot_prod$[ebp], ecx	;Save current value dot_prod

; 24   : 		}

	jmp	SHORT $LN2@vdp_sequen
$LN1@vdp_sequen:

; 25   : 
; 26   : 	return (dot_prod.sum1);

	mov	eax, DWORD PTR _dot_prod$[ebp]

; 27   : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_vdp_sequential ENDP
_TEXT	ENDS
END
